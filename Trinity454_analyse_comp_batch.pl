#!/usr/bin/perl
# a wrapper around the align and analyse scripts for batch processing
use strict; use warnings;


my $first = 1;
my @fields;
my $seqno;
my $seq_count = 0;
my $component;
my @alignment_names;
my $comp_count = 0;
my %original_name;
my %reverse;
my $extension;
my $alignment;
my $al;
my $i;

# Supply non-existing dummy name for the last batch as stop component. The while loop will exist at eof. 
# The input file contains a list of Trinity contigs to be analysed.
# For a group of sequenes within a cluster,an alignment is generated by passing the component name and the 
# indices of the sequences to Trinity_align_components3.pl

die "Usage: input file with sequence names, start component and stop component needed.\n" if (@ARGV != 3);
my ($infilename, $first_comp, $stop_comp) = @ARGV;


open (my $in, "< $infilename") or die "Can't open $infilename\n";
my $outfilename = 'aligned_components.txt';
my $out;

my $buffer = '';
my $do_alignment = 0;
my $alignment_count = 0;

while (my $line = <$in>) {
	chomp($line);
	@fields = split ('\t',$line);
	$fields[0] =~ /_seq/;
	$component = $`;
	$seqno = $';
      	# extract component name  
	if ($component eq $first_comp) {
		$do_alignment = 1;
	}
	elsif ($component eq $stop_comp) {
		last;
	}
	if ($do_alignment) {
		if (!($component eq $buffer)) {   # if new component, then construct the alignment call for the previous component
			if ($first) {
				$first = 0;
			}
			else {
				for ($i=2;$i<=$seq_count;$i++) {
#					print "perl /users/bnurnberger/Trinity_components/Trinity454_align_components.pl $buffer $original_name{1} $original_name{$i} $reverse{$i}\n";
					system "perl /users/bnurnberger/Trinity_components/Trinity454_align_components.pl $buffer $original_name{1} $original_name{$i} $reverse{$i}";
					$extension = '_1' . $i;
					$alignment = $buffer . $extension;
					system "mv $buffer.afa2 $alignment.afa2";
					push @alignment_names, $alignment;
					$alignment_count++;
				}
				$seq_count = 0;

				if ($alignment_count >=  50) {

					# write the names of all aligned components to one file
					open ($out, "> $outfilename") or die "Can't create $outfilename\n";
					foreach $al (@alignment_names) {
						print $out "$al\n";
					}
					close ($out);
					system "perl /users/bnurnberger/Trinity_components/Trinity454_analyse_components.pl $outfilename";
					@alignment_names = ();
					$alignment_count = 0;
				}
			}
			$buffer = $component;
			$comp_count++;
		}
		$seq_count++;
		$original_name{$seqno} = $fields[1];
		if ($seqno > 1) { $reverse{$seqno} = $fields[2] }
	}
}

# do the alignment for the last component to be analysed
for ($i=2;$i<=$seq_count;$i++) {
	system "perl /users/bnurnberger/Trinity_components/Trinity454_align_components.pl $buffer $original_name{1} $original_name{$i} $reverse{$i}";
	$extension = '_1' . $i;
	$alignment = $buffer . $extension;
	system "mv $buffer.afa2 $alignment.afa2";
	push @alignment_names, $alignment;
}

# write the names of all aligned components to one file
open ($out, "> $outfilename") or die "Can't create $outfilename\n";
foreach $al (@alignment_names) {
	print $out "$al\n";
}

close ($in);
close ($out);	

system ("perl /users/bnurnberger/Trinity_components/Trinity454_analyse_components.pl $outfilename");
