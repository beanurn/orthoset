#!/usr/bin/perl
# a wrapper around the align and analyse scripts for batch processing
use strict; use warnings;


my $first = 1;
my @seqnumbers = ();
my $component;
my @alignment_names;
my $comp_count = 0;
my $extension;
my $alignment;
my @fields;
my $ref_flag;
my $al;
my $i;

# Supply non-existing dummy name for the last batch as stop component. The while loop will exist at eof. 
# The input file contains a list of Trinity contigs to be analysed.
# For a group of sequenes within a cluster,an alignment is generated by passing the component name and the 
# indices of the sequences to Trinity_align_components3.pl

die "Usage: input file with sequence names, start component and stop component needed.\n" if (@ARGV != 3);
my ($infilename, $first_comp, $stop_comp) = @ARGV;

open (my $in, "< $infilename") or die "Can't open $infilename\n";
my $outfilename = 'aligned_components.txt';
my $out;
open ($out, "> $outfilename") or die "Can't create $outfilename\n";

my $buffer = '';
my $do_alignment = 0;
my $alignment_count = 0;
my $ref = 0;

while (my $line = <$in>) {
	chomp($line);
	@fields = split ('\t',$line);
	$fields[0] =~ /_seq/;
	$component = $`;      			# extract component name  
	$ref_flag = $fields[1];
	if ($component eq $first_comp) {
		$do_alignment = 1;
	}
	elsif ($component eq $stop_comp) {
		last;
	}
	if ($do_alignment) {
		if (!($component eq $buffer)) {   # if new component, then construct the alignment call for the previous component
			if ($first) {
				$first = 0;
			}
			else {
#				print "Trinity_analyse_comp_batch.pl: about to align component $buffer\n";
				for ($i=0;$i<@seqnumbers;$i++) {
					unless ($seqnumbers[$i] == $ref) {
						if ($seqnumbers[$i] > $ref) {
							system "perl /users/bnurnberger/Trinity_components/Trinity_align_components4.pl $buffer $ref $seqnumbers[$i]";
						}
						else {
							system "perl /users/bnurnberger/Trinity_components/Trinity_align_components4.pl $buffer $seqnumbers[$i] $ref";
						}
						$extension = '_' . $ref . $seqnumbers[$i];
						$alignment = $buffer . $extension;
						system "mv $buffer.afa2 $alignment.afa2";
						push @alignment_names, $alignment;
						$alignment_count++;
					}
				}
				@seqnumbers = ();
				$ref = 0;

				if ($alignment_count >=  50) {

					# write the names of all aligned components to one file
					foreach $al (@alignment_names) {
						print $out "$al\n";
					}
					close ($out);
					system "perl /users/bnurnberger/Trinity_components/Trinity_analyse_components2.pl $outfilename";
					@alignment_names = ();
					open ($out, "> $outfilename") or die "Can't create $outfilename\n";
					$alignment_count = 0;
				}
			}
			$buffer = $component;
			$comp_count++;
		}
		push @seqnumbers, $';
		if ($ref == 0 and $ref_flag == 1) { $ref = $' }
	}
}

# do the alignment for the last component to be analysed
for ($i=1;$i<@seqnumbers;$i++) {
	unless ($seqnumbers[$i] == $ref) {
		print "$buffer, aligning $ref (ref) and $seqnumbers[$i]\n";
		if ($seqnumbers[$i] > $ref) {
			system "perl /users/bnurnberger/Trinity_components/Trinity_align_components4.pl $buffer $ref $seqnumbers[$i]";
		}
		else {
			system "perl /users/bnurnberger/Trinity_components/Trinity_align_components4.pl $buffer $seqnumbers[$i] $ref";
		}
		$extension = '_' . $ref . $seqnumbers[$i];
		$alignment = $buffer . $extension;
		system "mv $buffer.afa2 $alignment.afa2";
		push @alignment_names, $alignment;
	}
}

# write the names of all aligned components to one file
foreach $al (@alignment_names) {
	print $out "$al\n";
}

close ($in);
close ($out);	

system ("perl /users/bnurnberger/Trinity_components/Trinity_analyse_components2.pl $outfilename");
